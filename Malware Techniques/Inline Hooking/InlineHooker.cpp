#include <Windows.h>
#include <stdio.h>

byte original_bytes[5];

typedef int(WINAPI *Trampoline)(HWND hwnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType);
Trampoline trampoline;

int WINAPI HookedMessageBoxA(HWND hwnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType) {
	return 	trampoline(NULL, "MessageBox call has been hooked!", "HookedMessageBoxA", MB_OK);;
}

void hook(LPVOID trampoline) {

	BYTE jump[5] = { 0xE9, 0x00, 0x00, 0x00, 0x00 };
	DWORD old_permissions;
	DWORD destination;
	
	//Loading User32.dll and getting MessageBoxA address
	LoadLibrary(L"User32.dll");
	HMODULE hModule = GetModuleHandle(L"user32.dll");
	byte* messagebox_address = (byte*)GetProcAddress(hModule, "MessageBoxA");

	if (VirtualProtect(messagebox_address, 5, PAGE_EXECUTE_READWRITE, &old_permissions) == 0) {
		printf("VirtualProtect execution failed!\n");
		exit(0);
	}

	//Creating trampoline
	*(LPVOID*)trampoline = VirtualAlloc(NULL, 10, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	LPVOID trampoline_address = *(LPVOID*)trampoline;
	memcpy(trampoline_address, messagebox_address, 5);
	//Also, preamble is saved in order to undo the hook later
	memcpy(original_bytes, messagebox_address, 5);
	
	//Calculate relative jump from Trampolin to the original Messagebox function
	destination = ((DWORD)messagebox_address + 5) - ((DWORD)trampoline_address + 5);
	*(DWORD*)(jump + 1) = destination;
	memcpy((LPVOID)((DWORD)trampoline_address +5), jump, 5);

	//Hooking function
	//Calculate relative address to our Hooked MessageBoxA function
	destination = (DWORD)HookedMessageBoxA - ((DWORD)messagebox_address + 5);
	*(DWORD*)(jump + 1) = destination;
	memcpy(messagebox_address, jump, 5);

	//Restoring old memorie permissions
	VirtualProtect(messagebox_address, 5, old_permissions, &old_permissions);
}

void unhook() {
	
	DWORD old_permissions;

	HMODULE hModule = GetModuleHandle(L"user32.dll");
	FARPROC messagebox_address = GetProcAddress(hModule, "MessageBoxA");

	VirtualProtect(messagebox_address, 5, PAGE_EXECUTE_READWRITE, &old_permissions);
	memcpy(messagebox_address, original_bytes, 5);
	VirtualProtect(messagebox_address, 5, old_permissions, &old_permissions);
}

int main() {

	hook(&trampoline);
	MessageBoxA(NULL, "MessageBoxA has been called!", "MessageBoxA", MB_OK);
	unhook();
	MessageBoxA(NULL, "MessageBoxA has been called!", "MessageBoxA", MB_OK);

	return 0;
}